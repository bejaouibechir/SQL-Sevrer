# Importation exportation des données

Voici une nouvelle série de **20 exercices** pour le thème **Import/Export de données**. Ces exercices incluent explicitement la **connexion au serveur SQL** pour les commandes `bcp` et intègrent des cas pratiques utilisant des **fichiers de format (.fmt)**.

---

### **Exercice 1 : Exporter des données en CSV avec connexion explicite**
1. **Objectif** : Exporter les données de la table `Sales.SalesOrderHeader` dans un fichier CSV.
2. **Commande** :
   ```cmd
   bcp "SELECT * FROM AdventureWorks2022.Sales.SalesOrderHeader" queryout "C:\Exports\SalesOrderHeader.csv" -c -S SERVER_NAME -U sa -P YourPassword
   ```
3. **Résultat attendu** : Les données sont exportées dans un fichier CSV nommé `SalesOrderHeader.csv`.

---

### **Exercice 2 : Créer un fichier de format pour une table**
1. **Objectif** : Générer un fichier de format pour la table `Sales.SalesOrderHeader`.
2. **Commande** :
   ```cmd
   bcp AdventureWorks2022.Sales.SalesOrderHeader format nul -c -f "C:\Exports\SalesOrderHeader.fmt" -S SERVER_NAME -U sa -P YourPassword
   ```
3. **Résultat attendu** : Un fichier de format nommé `SalesOrderHeader.fmt` est créé.

---

### **Exercice 3 : Importer des données à l’aide d’un fichier de format**
1. **Objectif** : Charger un fichier CSV dans une table existante à l’aide d’un fichier de format.
2. **Étapes** :
   - Créez un fichier CSV `SalesOrderData.csv` contenant :
     ```
     1,2024-01-01,1000.00
     2,2024-01-02,1500.00
     ```
   - Importez les données avec le fichier de format généré précédemment :
     ```cmd
     bcp AdventureWorks2022.Sales.SalesOrderHeader in "C:\Exports\SalesOrderData.csv" -f "C:\Exports\SalesOrderHeader.fmt" -S SERVER_NAME -U sa -P YourPassword
     ```
3. **Résultat attendu** : Les données du fichier CSV sont insérées dans la table `Sales.SalesOrderHeader`.

---

### **Exercice 4 : Exporter une requête complexe avec un fichier de format**
1. **Objectif** : Exporter une requête personnalisée dans un fichier texte à l’aide d’un fichier de format.
2. **Étapes** :
   - Générez un fichier de format pour la requête :
     ```cmd
     bcp "SELECT SalesOrderID, OrderDate, TotalDue FROM AdventureWorks2022.Sales.SalesOrderHeader" format nul -c -f "C:\Exports\CustomQuery.fmt" -S SERVER_NAME -U sa -P YourPassword
     ```
   - Exportez les données :
     ```cmd
     bcp "SELECT SalesOrderID, OrderDate, TotalDue FROM AdventureWorks2022.Sales.SalesOrderHeader" queryout "C:\Exports\CustomQueryData.txt" -f "C:\Exports\CustomQuery.fmt" -S SERVER_NAME -U sa -P YourPassword
     ```
3. **Résultat attendu** : Les données sont exportées avec la structure définie dans le fichier de format.

---

### **Exercice 5 : Importer un fichier texte avec des colonnes personnalisées**
1. **Objectif** : Importer un fichier texte structuré dans une table SQL.
2. **Étapes** :
   - Créez un fichier texte nommé `CustomSalesData.txt` contenant :
     ```
     1|2024-01-01|1000.00
     2|2024-01-02|1500.00
     ```
   - Générez un fichier de format pour les colonnes personnalisées :
     ```cmd
     bcp AdventureWorks2022.Sales.SalesOrderHeader format nul -c -t "|" -f "C:\Exports\CustomFormat.fmt" -S SERVER_NAME -U sa -P YourPassword
     ```
   - Importez les données :
     ```cmd
     bcp AdventureWorks2022.Sales.SalesOrderHeader in "C:\Exports\CustomSalesData.txt" -f "C:\Exports\CustomFormat.fmt" -S SERVER_NAME -U sa -P YourPassword
     ```
3. **Résultat attendu** : Les données sont insérées avec des colonnes séparées par `|`.

---

### **Exercice 6 : Exporter des données avec un fichier JSON**
1. **Objectif** : Exporter les données en JSON.
2. **Commande** :
   ```cmd
   bcp "SELECT * FROM AdventureWorks2022.Sales.SalesOrderHeader FOR JSON AUTO" queryout "C:\Exports\SalesData.json" -c -S SERVER_NAME -U sa -P YourPassword
   ```
3. **Résultat attendu** : Les données JSON sont exportées dans un fichier.

---

### **Exercice 7 : Exporter des données XML avec un fichier de format**
1. **Objectif** : Exporter les données en XML en utilisant un fichier de format.
2. **Étapes** :
   - Générez un fichier de format :
     ```cmd
     bcp AdventureWorks2022.Sales.SalesOrderHeader format nul -c -f "C:\Exports\XMLFormat.fmt" -S SERVER_NAME -U sa -P YourPassword
     ```
   - Exportez les données en XML :
     ```cmd
     bcp "SELECT * FROM AdventureWorks2022.Sales.SalesOrderHeader FOR XML AUTO" queryout "C:\Exports\SalesData.xml" -f "C:\Exports\XMLFormat.fmt" -S SERVER_NAME -U sa -P YourPassword
     ```
3. **Résultat attendu** : Les données XML sont exportées dans un fichier.

---

### **Exercice 8 : Charger des données avec validation des formats**
1. **Objectif** : Valider le format des données avant de les insérer.
2. **Étapes** :
   - Créez un fichier CSV `ValidatedData.csv` contenant :
     ```
     1,John Doe,100.50
     2,Jane Smith,200.75
     ```
   - Générez un fichier de format correspondant :
     ```cmd
     bcp AdventureWorks2022.Customers format nul -c -f "C:\Exports\ValidatedFormat.fmt" -S SERVER_NAME -U sa -P YourPassword
     ```
   - Importez les données avec validation :
     ```cmd
     bcp AdventureWorks2022.Customers in "C:\Exports\ValidatedData.csv" -f "C:\Exports\ValidatedFormat.fmt" -S SERVER_NAME -U sa -P YourPassword
     ```
3. **Résultat attendu** : Les données correctement formatées sont insérées.

### **Exercice 9 : Transformer les données avec SSIS**

Ce tutoriel traite les sujets suivants:

1. **Les contraintes de précédence** (succès, échec, achèvement).
2. **La combinaison de résultats et expressions** dans une contrainte de précédence.
3. **L'utilisation de variables et d'une tâche d'expression**.

---

### **Objectif**
Créer un package SSIS qui :
1. Intègre deux sources de données (SQL et CSV).
2. Montre l’utilité des transformations SSIS (jointure, split conditionnel, et calcul).
3. Démonstre les contraintes de précédence avec :
   - Conditions de **succès**, **échec**, et **achèvement**.
   - Utilisation de **variables** et d’**expressions** pour évaluer une contrainte.
4. Ajoute une tâche d’expression pour calculer une valeur ou assigner une variable.

---

### **Étapes détaillées**

#### **1. Préparation des sources**
1. **Table SQL :**
   - Table : `Sales.SalesOrderHeader` d'AdventureWorks2019.
   - Colonnes : `SalesOrderID`, `CustomerID`, `OrderDate`.

2. **Fichier CSV :**
   - Créez `CustomerData.csv` avec le contenu suivant (placez-le dans `C:\temp`):
     ```csv
     CustomerID,CustomerName,Region
     11000,John Doe,North
     11001,Jane Smith,South
     11002,Mike Brown,West
     11003,Susan Green,East
     ```

---

#### **2. Configuration du package SSIS**
1. **Créer un nouveau package :**
   - Nommez-le `JoinSplitExpressionWithConstraints.dtsx`.

2. **Ajouter une variable :**
   - Créez une variable nommée `SuccessCount` de type `Int32`, initialisée à `0`.

---

#### **3. Ajout des composants principaux**
1. **Sources de données :**
   - Configurez un **OLE DB Source** pour la table SQL (voir requête précédente).
   - Configurez un **Flat File Source** pour lire `CustomerData.csv`.

2. **Jointure des données :**
   - Ajoutez un composant **Merge Join** pour une **Inner Join** sur `CustomerID`.

3. **Split conditionnel :**
   - Ajoutez un composant **Conditional Split** avec deux conditions :
     - `Region == "North"` (sortie : `NorthRegion`).
     - `Region != "North"` (sortie : `OtherRegions`).

4. **Calcul avec Derived Column :**
   - Ajoutez un composant **Derived Column** après `OtherRegions`.
   - Calculez une colonne `DiscountedPrice` avec :
     ```sql
     100 - (DATEPART("yyyy", GETDATE()) - DATEPART("yyyy", [OrderDate])) * 5
     ```

---

#### **4. Ajout des contraintes de précédence**
1. **Ajouter une tâche d'expression (Expression Task) :**
   - Placez une **Script Task** avant les transformations.
   - Implémentez le code suivant pour initialiser `SuccessCount` :
     ```csharp
     public void Main()
     {
         Dts.Variables["User::SuccessCount"].Value = 0;
         Dts.TaskResult = (int)ScriptResults.Success;
     }
     ```

2. **Configurer les contraintes de précédence :**
   - **Entre la tâche d'expression et la jointure :**
     - Contrainte : **Succès**.
     - Ajoutez une condition d'expression combinée :
       ```sql
       @SuccessCount == 0 && @[System::TaskName] == "Initialize"
       ```

   - **Entre la jointure et le split conditionnel :**
     - Contrainte : **Succès**.

   - **Entre le split conditionnel et les tâches de destination :**
     - `NorthRegion` :
       - Contrainte : **Succès** avec expression `@[User::SuccessCount] > 0`.
     - `OtherRegions` :
       - Contrainte : **Achèvement**.

---

#### **5. Chargement des résultats**
1. **Sortie `NorthRegion` :**
   - Configurez une **Flat File Destination** vers `C:\temp\NorthRegionOutput.csv`.

2. **Sortie `OtherRegions` :**
   - Configurez une **OLE DB Destination** vers une table nommée `ProcessedOrders`.

3. **Tâche supplémentaire pour tester l’échec :**
   - Ajoutez une **Script Task** avec un code qui force un échec :
     ```csharp
     public void Main()
     {
         throw new Exception("Simulated failure");
     }
     ```

---

### **Résultat attendu**
1. **Fichiers générés :**
   - `NorthRegionOutput.csv` pour les commandes de la région Nord.
   - Table SQL `ProcessedOrders` pour les autres commandes avec une colonne calculée.

2. **Démonstration des contraintes :**
   - Si la première tâche échoue, aucune transformation ne se produit.
   - Si `SuccessCount > 0`, seules les commandes de la région Nord sont traitées.

3. **Utilisation de la variable et de l’expression :**
   - La variable `SuccessCount` pilote certaines conditions.
   - Les contraintes utilisent des expressions combinées.
